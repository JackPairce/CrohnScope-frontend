"use client";
import { MaskToArray } from "@/components/AnnotationCanvas/MaskUtils";
// Generated by Copilot

import { SaveSatues, Tab } from "@/components/AnnotationCanvas/types";
import ConfirmDialog, { DialogAction } from "@/components/ConfirmDialog";
import { ApiImage, SaveMaskRequest, uploadMasks } from "@/lib/api"; // Import the components type from API
import { components } from "@/lib/api/types"; // Import the components type from API
import {
  createContext,
  Dispatch,
  ReactNode,
  SetStateAction,
  useContext,
  useRef,
  useState,
} from "react";

// Define the SaveMaskResponse type based on the API schema
type SaveMaskResponse = components["schemas"]["SaveMaskResponse"];

type ImageSwitchChoice = "stay" | "continue-without-save" | "save-and-continue";

// Implementation moved to the AnnotationProvider component

interface AnnotationContextState {
  // Current image
  currentImage: ApiImage | null;

  setCurrentImage: (image: ApiImage | null) => Promise<void>;

  // Save status
  saveStatus: SaveSatues;

  setSaveStatus: Dispatch<SetStateAction<SaveSatues>>;

  // Tabs
  tabs: Tab[];

  setTabs: Dispatch<SetStateAction<Tab[]>>;
  selectedTab: number;

  setSelectedTab: Dispatch<SetStateAction<number>>;

  // Image dimensions
  imgDim: { width: number; height: number } | null;

  setImgDim: Dispatch<SetStateAction<{ width: number; height: number } | null>>;

  // Loading state
  isLoading: boolean;
  setIsLoading: Dispatch<SetStateAction<boolean>>;

  // Save current annotations
  saveCurrent: () => Promise<void>;
}

const defaultState: AnnotationContextState = {
  currentImage: null,
  setCurrentImage: async () => {},
  saveStatus: {
    isSaving: false,
    isModified: false,
    isMarkingAllDone: false,
  },
  setSaveStatus: () => {},
  tabs: [],
  setTabs: () => {},
  selectedTab: -1,
  setSelectedTab: () => {},
  imgDim: null,
  setImgDim: () => {},
  isLoading: false,
  setIsLoading: () => {},
  saveCurrent: async () => {},
};

const AnnotationContext = createContext<AnnotationContextState>(defaultState);

export function AnnotationProvider({ children }: { children: ReactNode }) {
  const [currentImage, setCurrentImageState] = useState<ApiImage | null>(null);
  const [saveStatus, setSaveStatus] = useState<SaveSatues>(
    defaultState.saveStatus
  );
  const [tabs, setTabs] = useState<Tab[]>([]);
  const [selectedTab, setSelectedTab] = useState(-1);
  const [imgDim, setImgDim] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Function to handle saving the current state
  const saveCurrent = async (): Promise<void> => {
    try {
      // Set saving state
      setSaveStatus((prev) => ({ ...prev, isSaving: true }));

      // Ensure we have an image and tabs to save
      if (!currentImage?.id || tabs.length === 0) {
        console.log("No image or tabs to save");
        setSaveStatus((prev) => ({ ...prev, isSaving: false }));
        return;
      }

      // Convert tabs to SaveMaskResponse format for API
      const masksToSave: SaveMaskRequest = tabs
        .filter((tab) => tab.mask) // Only process tabs with masks
        .map((tab) => ({
          id: tab.mask_id || 0, // Use existing ID if available, otherwise 0 for new
          cell_id: tab.cell_id,
          data: MaskToArray(tab.mask),
        }));

      if (masksToSave.length > 0) {
        // Call API to save masks
        await uploadMasks(currentImage.id, masksToSave);

        // For now, simulate API call delay
        await new Promise((resolve) => setTimeout(resolve, 800));
      }

      // Update tabs to mark them as saved
      setTabs((currentTabs) =>
        currentTabs.map((tab) => ({
          ...tab,
          // An actual API call would return the new mask_id for new tabs
          mask_id: tab.mask_id || Math.floor(Math.random() * 10000), // Just for simulation
        }))
      );

      // Update save status
      setSaveStatus({
        isSaving: false,
        isModified: false,
        isMarkingAllDone: false,
      });

      return Promise.resolve();
    } catch (error) {
      console.error("Error saving annotations:", error);
      setSaveStatus((prev) => ({ ...prev, isSaving: false }));
      return Promise.reject(error);
    }
  };

  const [showDialog, setShowDialog] = useState(false);
  const [pendingImage, setPendingImage] = useState<ApiImage | null>(null);
  const [dialogActions, setDialogActions] = useState<
    DialogAction<ImageSwitchChoice>[]
  >([]);

  const confirmImageSwitch = (): Promise<ImageSwitchChoice> => {
    return new Promise((resolve) => {
      setDialogActions([
        {
          label: "Continue Working",
          value: "stay",
          type: "default",
          autoFocus: true,
        },
        {
          label: "Continue Without Saving",
          value: "continue-without-save",
          type: "warning",
        },
        {
          label: "Save and Continue",
          value: "save-and-continue",
          type: "primary",
        },
      ]);

      // Store the resolve function to call it when dialog closes
      dialogResolveRef.current = resolve;
      setShowDialog(true);
    });
  };

  // Reference to store the resolve function
  const dialogResolveRef = useRef<(value: ImageSwitchChoice) => void>(() => {});

  // Dialog close handler
  const handleDialogClose = (value: ImageSwitchChoice) => {
    setShowDialog(false);
    if (dialogResolveRef.current) {
      dialogResolveRef.current(value);
    }
  };

  const handleImageSwitch = async (newImage: ApiImage | null) => {
    try {
      // If there are unsaved changes
      if (saveStatus.isModified) {
        // Store the pending image
        setPendingImage(newImage);

        // Show dialog and wait for response
        const choice = await confirmImageSwitch();

        switch (choice) {
          case "stay":
            // Clear pending image and throw UNSAVED_CHANGES to cancel the switch
            setPendingImage(null);
            throw new Error("UNSAVED_CHANGES");
          case "save-and-continue":
            try {
              await saveCurrent();
            } catch (error) {
              console.error("Error saving:", error);
              setPendingImage(null);
              throw error;
            }
            break;
          case "continue-without-save":
            // Just continue without saving
            break;
        }
      }

      // Clear the state when switching images
      setTabs([]);
      setSelectedTab(-1);
      setImgDim(null);
      setSaveStatus({
        isSaving: false,
        isModified: false,
        isMarkingAllDone: false,
      });

      // Finally set the new image
      setCurrentImageState(newImage);
      setPendingImage(null);
    } catch (error) {
      // Re-throw UNSAVED_CHANGES so useImages can handle it appropriately
      if (error instanceof Error && error.message === "UNSAVED_CHANGES") {
        throw error;
      }
      console.error("Error switching image:", error);
      throw new Error("Failed to switch image");
    }
  };

  const contextValue: AnnotationContextState = {
    currentImage,
    setCurrentImage: handleImageSwitch,
    saveStatus,
    setSaveStatus,
    tabs,
    setTabs,
    selectedTab,
    setSelectedTab,
    imgDim,
    setImgDim,
    isLoading,
    setIsLoading,
    saveCurrent,
  };

  return (
    <AnnotationContext.Provider value={contextValue}>
      {children}
      {showDialog && (
        <ConfirmDialog
          isOpen={showDialog}
          title="Unsaved Changes"
          message="You have unsaved changes. What would you like to do?"
          dialogType="warning"
          actions={dialogActions}
          onClose={handleDialogClose}
        />
      )}
    </AnnotationContext.Provider>
  );
}

export function useAnnotationContext() {
  const context = useContext(AnnotationContext);
  if (context === undefined) {
    throw new Error(
      "useAnnotationContext must be used within an AnnotationProvider"
    );
  }
  return context;
}
