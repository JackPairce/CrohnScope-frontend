// Generated by Copilot
import { useImages as useAnnotationImages } from "@/components/AnnotationCanvas/ImagesNav/useImages";
import { ApiImage } from "@/components/AnnotationCanvas/api";
import { ToastType } from "@/components/Toast";
import { useCallback, useState } from "react";

// This wrapper adapts the AnnotationCanvas useImages hook for the Images page
export function useImages() {
  const [dummyImage, setDummyImage] = useState<ApiImage | null>(null);

  // Create a dummy toast function that's not used (the component handles toasts separately)
  const dummyToast = useCallback((_message: string, _type: ToastType) => {},
  []);

  const hookResult = useAnnotationImages(false, dummyToast, (img) =>
    setDummyImage(img)
  );

  // Map returned API images to the format expected by our component
  const mappedImages =
    hookResult.images?.map((image) => ({
      ...image,
      // Add properties our component expects but aren't in the ApiImage interface
      name: image.filename,
      url: image.src,
      width: 800, // Default values since these aren't in the API response
      height: 600,
    })) || [];

  return {
    images: mappedImages,
    isLoading: hookResult.isLoading,
    isError: hookResult.isError ? hookResult.isError : "",
    error: hookResult.isError ? new Error(hookResult.isError) : null,
    refetch: useCallback(() => {
      // In a real implementation, we would use React Query's refetch
      // or reset page to 1 and force a reload
      window.location.reload();
    }, []),
    uploadImage: hookResult.handleUploadImage,
    // This is a dummy function since we're handling uploading state in the component
    setUploadingState: () => {},
    // Expose the deleteImage function from the hook
    deleteImage: hookResult.handleDeleteImage,
  };
}
