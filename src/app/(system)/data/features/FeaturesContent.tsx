"use client";

// Generated by Copilot
import ConfirmDialog from "@/components/ConfirmDialog";
import Loader from "@/components/loader";
import Toast, { ToastContainer, ToastType } from "@/components/Toast";
import {
  addFeatures,
  ApiFeature,
  deleteFeatures,
  getFeatures,
  updateFeatures,
} from "@/lib/api";
import { useEffect, useState } from "react";
import {
  FeatureDetails,
  FeatureForm,
  FeatureHeader,
  FeatureList,
} from "./components";

export default function FeaturesContent() {
  const [features, setFeatures] = useState<ApiFeature[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedFeature, setSelectedFeature] = useState<ApiFeature | null>(
    null
  );
  const [editMode, setEditMode] = useState<"view" | "edit" | "add">("view");
  const [formData, setFormData] = useState<Partial<ApiFeature>>({});
  const [toasts, setToasts] = useState<
    Array<{ id: string; message: string; type: ToastType }>
  >([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [featureToDelete, setFeatureToDelete] = useState<ApiFeature | null>(
    null
  );
  const [maxSeverity, setMaxSeverity] = useState(1);

  const addToast = (message: string, type: ToastType) => {
    const id = Date.now().toString();
    setToasts((prev) => [...prev, { id, message, type }]);
  };

  const removeToast = (id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  };

  useEffect(() => {
    (async () => {
      setIsLoading(true);
      try {
        const data = await getFeatures();
        setFeatures(data);
        setMaxSeverity(Math.max(...data.map((f) => f.severity || 1)) || 1);
      } catch (error) {
        console.error("Error fetching features:", error);
        addToast("Failed to load features", "error");
      } finally {
        setIsLoading(false);
      }
    })();
  }, []);
  const handleAdd = () => {
    setSelectedFeature(null);
    setFormData({});
    setEditMode("add");
  };

  const handleEdit = (feature: ApiFeature) => {
    setSelectedFeature(feature);
    setFormData({ ...feature });
    setEditMode("edit");
  };

  const handleDelete = async (feature: ApiFeature) => {
    setFeatureToDelete(feature);
    setShowDeleteConfirm(true);
  };

  const handleDeleteConfirmed = async (id: number) => {
    try {
      await deleteFeatures(id);
      setFeatures((prev) => prev.filter((f) => f.id !== id));
      addToast("Feature deleted successfully", "success");
      setSelectedFeature(null);
      setMaxSeverity(
        Math.max(
          ...features.filter((f) => f.id !== id).map((f) => f.severity || 1)
        ) || 1
      );
    } catch (error) {
      console.error("Error deleting feature:", error);
      addToast("Failed to delete feature", "error");
    }
  };

  const handleSubmit = async (data: Partial<ApiFeature>) => {
    setIsSubmitting(true);
    let new_features = [...features];
    try {
      const submitData = { ...data } as ApiFeature;
      if (editMode === "add") {
        submitData.id = features.length + 1; // Temporary ID generation
        const response = await addFeatures(submitData);
        const newFeature = response.feature_type;
        new_features.push(newFeature);
        setFeatures(new_features);
        addToast(response.message || "Feature added successfully", "success");
      } else if (selectedFeature) {
        const response = await updateFeatures(submitData);
        const updatedFeature = response.feature_type;
        new_features = new_features.map((f) =>
          f.id === selectedFeature.id ? updatedFeature : f
        );
        setFeatures(new_features);
        addToast(response.message || "Feature updated successfully", "success");
      }
      setEditMode("view");
      setSelectedFeature(null);
    } catch (error) {
      console.error("Error saving feature:", error);
      addToast("Failed to save feature", "error");
    } finally {
      setMaxSeverity(
        Math.max(
          ...new_features.map((f) => f.severity || 1),
          data.severity || 1
        ) || 1
      );
      setIsSubmitting(false);
    }
  };

  const handleCancel = () => {
    setEditMode("view");
    setSelectedFeature(null);
  };

  if (isLoading) {
    return <Loader />;
  }

  return (
    <>
      <div className="features-content">
        <FeatureHeader
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          onAddNew={handleAdd}
        />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Left column: Features list */}
          <div className="lg:col-span-2">
            <div className="bg-white dark:bg-gray-800 shadow rounded-lg">
              <FeatureList
                features={features.filter(
                  (feature) =>
                    feature.name
                      .toLowerCase()
                      .includes(searchQuery.toLowerCase()) ||
                    feature.description
                      ?.toLowerCase()
                      .includes(searchQuery.toLowerCase())
                )}
                selectedFeature={selectedFeature}
                onSelect={setSelectedFeature}
                onEdit={handleEdit}
                onDelete={handleDelete}
                editMode={editMode}
                maxSeverity={{
                  value: maxSeverity,
                  setter: setMaxSeverity,
                }}
              />
            </div>
          </div>

          {/* Right column: Feature details or form */}
          <div>
            {editMode !== "view" ? (
              <FeatureForm
                formData={formData}
                editMode={editMode}
                isSubmitting={isSubmitting}
                onSubmit={handleSubmit}
                onCancel={handleCancel}
                existingFeatures={features}
                maxSeverity={{
                  value: maxSeverity,
                  setter: setMaxSeverity,
                }}
              />
            ) : selectedFeature ? (
              <FeatureDetails
                feature={selectedFeature}
                onEdit={handleEdit}
                onDelete={handleDelete}
                maxSeverity={{
                  value: maxSeverity,
                  setter: setMaxSeverity,
                }}
              />
            ) : (
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 h-64 flex flex-col items-center justify-center text-center">
                <svg
                  className="w-12 h-12 text-gray-400 mb-4"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  ></path>
                </svg>
                <p className="text-gray-500 dark:text-gray-400">
                  Select a feature from the list to view details or click "Add
                  New Feature" to create one
                </p>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Delete confirmation dialog */}
      {featureToDelete && (
        <ConfirmDialog
          isOpen={showDeleteConfirm}
          title="Delete Feature"
          message={`Are you sure you want to delete this feature${
            featureToDelete.name ? ` "${featureToDelete.name}"` : ""
          }? This action cannot be undone.`}
          dialogType="danger"
          actions={[
            {
              label: "Cancel",
              value: false,
              type: "default",
              autoFocus: true,
            },
            {
              label: "Delete",
              value: true,
              type: "danger",
            },
          ]}
          onClose={(confirmed: boolean) => {
            if (confirmed && featureToDelete) {
              handleDeleteConfirmed(featureToDelete.id);
            }
            setShowDeleteConfirm(false);
            setFeatureToDelete(null);
          }}
        />
      )}

      {/* Toast notifications */}
      <ToastContainer>
        {toasts.map(({ id, message, type }) => (
          <Toast
            key={id}
            message={message}
            type={type}
            onClose={() => removeToast(id)}
          />
        ))}
      </ToastContainer>
    </>
  );
}
