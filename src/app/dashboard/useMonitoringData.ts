// Generated by Copilot
import axios from "axios";
import { useEffect, useState } from "react";
import type { components } from "../../api";

// Base URL for API endpoints
const API_URL = process.env.NEXT_PUBLIC_API_URL;

// Constants
const METRICS_INTERVAL = 1000; // 1 second
const MONITORING_INTERVAL = 60000; // 1 minute
const CONNECTION_TIMEOUT = 3000; // 3 seconds

// Interfaces for API responses based on OpenAPI types
interface ModelStatus {
  isOnline: boolean;
  isTraining: boolean;
  accuracy: number;
  lastTrainingDate: string;
}

interface ImageStatus {
  totalImages: number;
  segmentedCount: number;
  labeledCount: number;
  labelDistribution: Record<string, number>;
}

// Using OpenAPI types for system monitoring
type SystemResponse = components["schemas"]["SystemResponse"];
type DataUsageResponse = components["schemas"]["DataUsageResponse"];
type SystemMetrics = components["schemas"]["SystemMetrics"];

type ConnectionStatus = "connected" | "connecting" | "disconnected";

type MonitoringData = {
  aiStatus: ModelStatus | null;
  imageStatus: ImageStatus | null;
  systemInfo: SystemResponse | null;
  dataUsage: DataUsageResponse | null;
  metrics: SystemMetrics | null;
  connectionStatus: ConnectionStatus;
  isLoading: boolean;
  error: Error | null;
  lastUpdate: Date;
};

export function useMonitoringData(): MonitoringData {
  const [data, setData] = useState<MonitoringData>({
    aiStatus: null,
    imageStatus: null,
    systemInfo: null,
    dataUsage: null,
    metrics: null,
    connectionStatus: "connecting",
    isLoading: true,
    error: null,
    lastUpdate: new Date(),
  });

  // Handle real-time metrics
  useEffect(() => {
    let metricsTimer: NodeJS.Timeout;
    let connectionTimer: NodeJS.Timeout;

    async function fetchMetrics() {
      try {
        // Start connection timer
        connectionTimer = setTimeout(() => {
          setData((prev) => ({
            ...prev,
            connectionStatus: "disconnected",
          }));
        }, CONNECTION_TIMEOUT);

        const response = await axios.get<SystemMetrics>(
          `${API_URL}/monitor/metrics`
        );

        // Clear connection timer as we got a response
        clearTimeout(connectionTimer);

        setData((prev) => ({
          ...prev,
          metrics: response.data,
          connectionStatus: "connected",
          lastUpdate: new Date(),
          error: null,
        }));
      } catch (error) {
        clearTimeout(connectionTimer);
        setData((prev) => ({
          ...prev,
          connectionStatus: "disconnected",
          error: axios.isAxiosError(error)
            ? new Error(error.response?.data?.message || error.message)
            : new Error("Failed to fetch metrics"),
        }));
      }
    }

    // Initial fetch
    fetchMetrics();

    // Set up interval for metrics
    metricsTimer = setInterval(fetchMetrics, METRICS_INTERVAL);

    return () => {
      clearInterval(metricsTimer);
      clearTimeout(connectionTimer);
    };
  }, []);

  // Handle regular monitoring data
  useEffect(() => {
    async function fetchMonitoringData() {
      try {
        const [aiStatusRes, imageStatusRes, systemInfoRes, dataUsageRes] =
          await Promise.all([
            axios.get<ModelStatus>(`${API_URL}/ai/status`),
            axios.get<ImageStatus>(`${API_URL}/image/status`),
            axios.get<SystemResponse>(`${API_URL}/monitor/system`),
            axios.get<DataUsageResponse>(`${API_URL}/monitor/data-usage`),
          ]);

        setData((prev) => ({
          ...prev,
          aiStatus: aiStatusRes.data,
          imageStatus: imageStatusRes.data,
          systemInfo: systemInfoRes.data,
          dataUsage: dataUsageRes.data,
          isLoading: false,
          error: null,
        }));
      } catch (error) {
        setData((prev) => ({
          ...prev,
          isLoading: false,
          error: axios.isAxiosError(error)
            ? new Error(error.response?.data?.message || error.message)
            : new Error("Failed to fetch monitoring data"),
        }));
      }
    }

    fetchMonitoringData();
    const interval = setInterval(fetchMonitoringData, MONITORING_INTERVAL);
    return () => clearInterval(interval);
  }, []);

  return data;
}
