// Generated by Copilot
import { useAnnotationContext } from "@/contexts/AnnotationContext";
import { ApiImage } from "@/lib/api";
import { RefObject, useEffect, useRef, useState } from "react";
import { LoadMasks } from "../MaskUtils";
import { Mode, SaveSatues, Tab } from "../types";

const initialState = {
  tabs: [] as Tab[],
  mode: "draw" as Mode,
  brushSize: 15,
  canvasSaveStatus: {
    isSaving: false,
    isModified: false,
    isMarkingAllDone: false,
  } as SaveSatues,
  isLoading: true,
  imgDim: null as { width: number; height: number } | null,
  selectedTab: NaN,
};

export type AnnotationCanvasState = {
  tabs: Tab[];
  canvasSaveStatus: SaveSatues;
  isLoading: boolean;
  imgDim: { width: number; height: number } | null;
  selectedTab: number;
  showSaveDialog: boolean;
  pendingImageChange: ApiImage | null;
  isAllDone: boolean;
};

export type AnnotationCanvasRefs = {
  overlayRef: RefObject<HTMLCanvasElement>;
};

export type AnnotationCanvasActions = {
  setTabs: React.Dispatch<React.SetStateAction<Tab[]>>;
  setSelectedTab: React.Dispatch<React.SetStateAction<number>>;
  setCanvasSaveStatus: React.Dispatch<React.SetStateAction<SaveSatues>>;
  setShowSaveDialog: React.Dispatch<React.SetStateAction<boolean>>;
  setPendingImageChange: React.Dispatch<React.SetStateAction<ApiImage | null>>;
  setCurrentMask: (mask: HTMLImageElement) => void;
  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;
  setImgDim: React.Dispatch<
    React.SetStateAction<{ width: number; height: number } | null>
  >;
  resetStates: () => void;
};

export function useAnnotationCanvas(image: ApiImage | null): {
  state: AnnotationCanvasState;
  refs: AnnotationCanvasRefs;
  actions: AnnotationCanvasActions;
} {
  const overlayRef = useRef<HTMLCanvasElement>(
    null
  ) as RefObject<HTMLCanvasElement>;

  // Get shared state from context
  const {
    currentImage,
    saveStatus: canvasSaveStatus,
    setSaveStatus: setCanvasSaveStatus,
    tabs,
    setTabs,
    selectedTab,
    setSelectedTab,
    imgDim,
    setImgDim,
    isLoading,
    setIsLoading,
  } = useAnnotationContext();

  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [pendingImageChange, setPendingImageChange] = useState<ApiImage | null>(
    null
  );

  // Keep track of previous image to detect actual changes
  const prevImageRef = useRef<ApiImage | null>(null);

  const resetStates = () => {
    setCanvasSaveStatus(initialState.canvasSaveStatus);
  };

  // Effect to handle image changes
  useEffect(() => {
    if (!image) return;

    // Check if image is actually changing
    const imageChanged =
      !prevImageRef.current || prevImageRef.current.id !== image.id;

    // If image hasn't changed, do nothing
    if (!imageChanged) return;

    // The image change and confirmation dialog is now handled by the AnnotationContext
    // This effect now just needs to load the new image data when the image changes

    // Load the new image
    setIsLoading(true);
    LoadMasks(image, setIsLoading, setImgDim, setTabs, setSelectedTab);

    // Update the prevImage ref
    prevImageRef.current = image;
  }, [image, canvasSaveStatus.isModified]);

  const setCurrentMask = (mask: HTMLImageElement) => {
    if (selectedTab === -1) return;
    setTabs((prev) => {
      prev[selectedTab].mask = mask;
      return [...prev];
    });
  };

  return {
    state: {
      tabs,
      selectedTab,
      canvasSaveStatus,
      isLoading,
      imgDim,
      showSaveDialog,
      pendingImageChange,
      isAllDone: tabs.every((tab) => tab.isDone),
    },
    refs: {
      overlayRef,
    },
    actions: {
      setTabs,
      setSelectedTab,
      setCanvasSaveStatus,
      setShowSaveDialog,
      setPendingImageChange,
      setCurrentMask,
      setIsLoading,
      setImgDim,
      resetStates,
    },
  };
}
