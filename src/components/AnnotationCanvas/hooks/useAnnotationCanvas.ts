// Generated by Copilot
import { useEffect, useRef, useState } from "react";
import { LoadMasks } from "../MaskUtils";
import { ApiImage } from "../api";
import { Mode, SaveSatues, Tab } from "../types";

const initialState = {
  tabs: [] as Tab[],
  mode: "draw" as Mode,
  brushSize: 15,
  canvasSaveStatus: {
    isSaving: false,
    isModified: false,
    isMarkingAllDone: false,
  } as SaveSatues,
  isLoading: true,
  imgDim: null as { width: number; height: number } | null,
  selectedTab: NaN,
};

export function useAnnotationCanvas(image: ApiImage | null) {
  const overlayRef = useRef<HTMLCanvasElement>(
    null
  ) as React.MutableRefObject<HTMLCanvasElement>;
  const [tabs, setTabs] = useState<Tab[]>(initialState.tabs);
  const [mode, setMode] = useState<Mode>(initialState.mode);
  const [brushSize, setBrushSize] = useState(initialState.brushSize);
  const [canvasSaveStatus, setCanvasSaveStatus] = useState<SaveSatues>(
    initialState.canvasSaveStatus
  );
  const [isLoading, setIsLoading] = useState(initialState.isLoading);
  const [imgDim, setImgDim] = useState(initialState.imgDim);
  const [selectedTab, setSelectedTab] = useState(initialState.selectedTab);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [pendingImageChange, setPendingImageChange] = useState<ApiImage | null>(
    null
  );

  // Keep track of previous image to detect actual changes
  const prevImageRef = useRef<ApiImage | null>(null);

  const resetStates = (
    loadPendingImage: boolean = false,
    saveMade: boolean = false
  ) => {
    // First clear dialog state
    setShowSaveDialog(false);

    // Store current pending image before clearing it
    const imageToLoad =
      loadPendingImage && pendingImageChange ? pendingImageChange : null;
    const pendingImage = pendingImageChange;

    // Clear pending image
    setPendingImageChange(null);

    if (loadPendingImage && imageToLoad) {
      // Handle confirmation - load the pending image after saving
      setTabs(initialState.tabs);
      setMode(initialState.mode);
      setBrushSize(initialState.brushSize);
      setCanvasSaveStatus(initialState.canvasSaveStatus);
      setIsLoading(true);
      setImgDim(initialState.imgDim);
      setSelectedTab(initialState.selectedTab);

      // Load new image
      LoadMasks(imageToLoad, setIsLoading, setImgDim, setTabs, setSelectedTab);

      // Update prevImage ref to prevent re-triggering dialog
      prevImageRef.current = imageToLoad;
    } else if (!loadPendingImage) {
      // Handle cancellation - reload the current image
      const currentImage = image || pendingImage;

      if (currentImage) {
        // Only reload data, don't reset UI state
        setIsLoading(true);
        LoadMasks(
          currentImage,
          setIsLoading,
          setImgDim,
          setTabs,
          setSelectedTab
        );

        // If we made a save, reset the modified flag
        if (saveMade) {
          setCanvasSaveStatus((prev) => ({
            ...prev,
            isModified: false,
          }));
        }

        // Update prevImage ref to prevent re-triggering dialog
        prevImageRef.current = currentImage;
      }
    }
  };

  // Effect to handle image changes
  useEffect(() => {
    if (!image) return;

    // Check if image is actually changing
    const imageChanged =
      !prevImageRef.current || prevImageRef.current.id !== image.id;

    // If image hasn't changed, do nothing
    if (!imageChanged) return;

    // If we have unsaved changes and image is changing, show dialog
    if (canvasSaveStatus.isModified && imageChanged) {
      setPendingImageChange(image);
      setShowSaveDialog(true);
      return;
    }

    // Otherwise load the new image
    setIsLoading(true);
    LoadMasks(image, setIsLoading, setImgDim, setTabs, setSelectedTab);

    // Update the prevImage ref
    prevImageRef.current = image;
  }, [image, canvasSaveStatus.isModified]);

  const setCurrentMask = (mask: HTMLImageElement) => {
    if (selectedTab === -1) return;
    setTabs((prev) => {
      prev[selectedTab].mask = mask;
      return [...prev];
    });
  };

  return {
    state: {
      tabs,
      mode,
      brushSize,
      canvasSaveStatus,
      isLoading,
      imgDim,
      selectedTab,
      showSaveDialog,
      pendingImageChange,
    },
    refs: {
      overlayRef,
    },
    actions: {
      setTabs,
      setMode,
      setBrushSize,
      setCanvasSaveStatus,
      setSelectedTab,
      setShowSaveDialog,
      setPendingImageChange,
      setCurrentMask,
      setIsLoading,
      setImgDim,
      resetStates,
    },
  };
}
