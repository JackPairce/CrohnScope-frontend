// Generated by Copilot
import { ApiImage, setMaskDone } from "@/lib/api";
import { Dispatch, SetStateAction } from "react";
import { SaveSatues } from "../types";

type CanvasState = {
  selectedTab: number;
  tabs: Array<{
    mask_id: number;
    isDone: boolean;
  }>;
};

type CanvasActions = {
  setTabs: Dispatch<SetStateAction<any[]>>;
  setCurrentImage: (image: ApiImage | null) => Promise<void>;
};

export type CanvasCallbacks = {
  saveCurrent?: () => Promise<void>;
  onMarkComplete?: (maskId: number) => Promise<void>;
};

export class CanvasActionsHandler {
  private state: CanvasState;
  private actions: CanvasActions;
  private setSaveStatus: Dispatch<SetStateAction<SaveSatues>>;
  private image: ApiImage;
  private callbacks: CanvasCallbacks;

  constructor(
    state: CanvasState,
    actions: CanvasActions,
    setSaveStatus: Dispatch<SetStateAction<SaveSatues>>,
    image: ApiImage,
    callbacks: CanvasCallbacks
  ) {
    this.state = state;
    this.actions = actions;
    this.setSaveStatus = setSaveStatus;
    this.image = image;
    this.callbacks = callbacks;
  }

  private async dispatchImageCompleted() {
    if (this.image && this.image.id) {
      const updatedImage = { ...this.image, is_done: true };
      // Fire event to update ImagesNav lists
      const event = new CustomEvent<{
        imageId: number;
        image: ApiImage;
      }>("imageCompleted", {
        detail: {
          imageId: this.image.id,
          image: updatedImage,
        },
      });
      window.dispatchEvent(event);
      // Set current image to null through AnnotationContext
      await this.actions.setCurrentImage(null);
    }
  }

  private async checkAndNotifyCompletion() {
    const allDone = this.state.tabs.every((tab) => tab.isDone);
    if (allDone) {
      await this.dispatchImageCompleted();
    }
  }

  async saveMasks() {
    try {
      // Try to use the provided saveCurrent function
      if (this.callbacks.saveCurrent) {
        await this.callbacks.saveCurrent();
      }
    } catch (error) {
      console.error("Failed to save masks:", error);
      this.setSaveStatus((prev) => ({
        ...prev,
        isSaving: false,
      }));
    }
  }

  async markCurrentMask() {
    if (
      this.state.selectedTab === -1 ||
      !this.state.tabs[this.state.selectedTab]
    )
      return;

    try {
      this.setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: true,
      }));

      const currentTab = this.state.tabs[this.state.selectedTab];

      // Use the provided onMarkComplete callback or fall back to default setMaskDone
      if (this.callbacks.onMarkComplete) {
        await this.callbacks.onMarkComplete(currentTab.mask_id);
      } else {
        await setMaskDone(currentTab.mask_id);
      }

      // Update local state
      this.actions.setTabs((prev) => {
        const newTabs = [...prev];
        newTabs[this.state.selectedTab] = {
          ...newTabs[this.state.selectedTab],
          isDone: true,
        };
        return newTabs;
      });

      // Check if this was the last unmarked tab
      const isLastOne =
        this.state.tabs.filter((tab) => !tab.isDone).length === 1;
      if (isLastOne) {
        await this.dispatchImageCompleted();
      }

      this.setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: false,
      }));
    } catch (error) {
      console.error("Failed to mark current mask as done:", error);
      this.setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: false,
      }));
    }
  }

  async markAllDone() {
    this.setSaveStatus((prev) => ({
      ...prev,
      isMarkingAllDone: true,
    }));

    try {
      // Mark each tab as done individually
      for (let i = 0; i < this.state.tabs.length; i++) {
        if (!this.state.tabs[i].isDone) {
          if (this.callbacks.onMarkComplete) {
            await this.callbacks.onMarkComplete(this.state.tabs[i].mask_id);
          } else {
            await setMaskDone(this.state.tabs[i].mask_id);
          }
        }
      }

      // Update all tabs in the UI at once
      this.actions.setTabs((prev) =>
        prev.map((tab) => ({ ...tab, isDone: true }))
      );

      // Always notify completion when marking all as done
      await this.dispatchImageCompleted();
    } catch (error) {
      console.error("Failed to mark all done:", error);
    } finally {
      this.setSaveStatus((prev) => ({
        isSaving: false,
        isMarkingAllDone: false,
        isModified: false,
      }));
    }
  }

  async saveAndMark() {
    try {
      this.setSaveStatus((prev) => ({
        ...prev,
        isSaving: true,
      }));

      await this.saveMasks();
      await this.markCurrentMask();

      this.setSaveStatus((prev) => ({
        ...prev,
        isSaving: false,
        isModified: false,
      }));
    } catch (error) {
      console.error("Failed to save and mark:", error);
      this.setSaveStatus((prev) => ({
        ...prev,
        isSaving: false,
        isMarkingAllDone: false,
      }));
    }
  }
}
