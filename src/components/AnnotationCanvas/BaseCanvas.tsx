// Generated by Copilot
import { ApiImage } from "@/lib/api";
import React, {
  Dispatch,
  ReactNode,
  RefObject,
  SetStateAction,
  useEffect,
  useRef,
  useState,
} from "react";
import Loader from "../loader";
import TabNavigation from "./TabNavigation";
import { SaveSatues, Tab } from "./types";

interface BaseCanvasProps {
  image: ApiImage;
  state: {
    tabs: Tab[];
    selectedTab: number;
    canvasSaveStatus: SaveSatues;
    imgDim: { width: number; height: number } | null;
    isLoading: boolean;
  };
  refs: {
    overlayRef: RefObject<HTMLCanvasElement>;
  };
  actions: {
    setTabs: Dispatch<SetStateAction<Tab[]>>;
    setSelectedTab: (index: number) => void;
    setIsLoading: Dispatch<SetStateAction<boolean>>;
  };
  toolbar: ReactNode; // Made optional
  children: ReactNode;
}

export default function BaseCanvas({
  image,
  state,
  refs,
  actions,
  toolbar,
  children,
}: BaseCanvasProps) {
  const ContainerRef = useRef<HTMLDivElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const minimapRef = useRef<HTMLDivElement>(null);

  // Add state for zoom level and panning
  const [zoom, setZoom] = useState<number>(1);
  const [position, setPosition] = useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  });
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [dragStart, setDragStart] = useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  });
  const [showMinimap, setShowMinimap] = useState<boolean>(false);
  const [triggerResize, setTriggerResize] = useState<boolean>(false);

  const resizeObserver = new ResizeObserver(() => {
    setTriggerResize((prev) => !prev);
  });
  // Generated by Copilot
  useEffect(() => {
    if (ContainerRef.current && imgRef.current) {
      const OriginalimgWidth = imgRef.current.naturalWidth;
      const OriginalimgHeight = imgRef.current.naturalHeight;
      const imgWidth = imgRef.current.clientWidth;
      const imgHeight = imgRef.current.clientHeight;

      const imgRatio = imgWidth / imgHeight;
      const OriginalimgRatio = OriginalimgWidth / OriginalimgHeight;
      if (imgRatio > OriginalimgRatio) {
        ContainerRef.current.style.width = `${imgHeight * OriginalimgRatio}px`;
      } else {
        ContainerRef.current.style.height = `${imgWidth / OriginalimgRatio}px`;
      }

      // Reset zoom and position when image changes
      setZoom(1);

      // Center the image in the container
      if (canvasContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgWidth) / 2,
          y: (containerRect.height - imgHeight) / 2,
        });
      }
    }
  }, [image, triggerResize]);
  // Handle mouse wheel zoom
  const handleZoom = (e: WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY;

    // Calculate new zoom level with limits
    const newZoom = Math.min(Math.max(zoom + (delta > 0 ? -0.1 : 0.1), 0.5), 5);

    // Get cursor position relative to canvas container
    const rect = canvasContainerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Adjust position to zoom toward the cursor position
    const newPosition = {
      x: mouseX - (mouseX - position.x) * (newZoom / zoom),
      y: mouseY - (mouseY - position.y) * (newZoom / zoom),
    };

    setZoom(newZoom);
    setPosition(newPosition);
  };

  // Handle mouse drag start
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0) {
      // Left button only
      setIsDragging(true);
      setDragStart({
        x: e.clientX - position.x,
        y: e.clientY - position.y,
      });
    }
  };

  // Handle mouse dragging
  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      setPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y,
      });
    }
  };

  // Handle mouse drag end
  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // Handle keyboard shortcuts for zoom
  // Generated by Copilot
  const handleKeyDown = (e: KeyboardEvent) => {
    // Ctrl/Cmd + plus key to zoom in
    if ((e.ctrlKey || e.metaKey) && e.key === "+") {
      e.preventDefault();
      setZoom(Math.min(zoom + 0.2, 5));
    }

    // Ctrl/Cmd + minus key to zoom out
    if ((e.ctrlKey || e.metaKey) && e.key === "-") {
      e.preventDefault();
      setZoom(Math.max(zoom - 0.2, 0.5));
    }

    // Ctrl/Cmd + 0 to reset zoom
    if ((e.ctrlKey || e.metaKey) && e.key === "0") {
      e.preventDefault();
      setZoom(1);
      // Center the image
      if (canvasContainerRef.current && ContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        const imgRect = ContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgRect.width / zoom) / 2,
          y: (containerRect.height - imgRect.height / zoom) / 2,
        });
      }
    }
  };
  // Add wheel event and keyboard listeners
  // Generated by Copilot
  useEffect(() => {
    const container = canvasContainerRef.current;
    if (container) {
      container.addEventListener("wheel", handleZoom, { passive: false });

      // Add keyboard event listener to the window
      window.addEventListener("keydown", handleKeyDown);
    }

    return () => {
      if (container) {
        container.removeEventListener("wheel", handleZoom);
      }
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [zoom, position]);

  // Show minimap when zoomed in beyond a threshold
  // Generated by Copilot
  useEffect(() => {
    if (zoom > 1.5) {
      setShowMinimap(true);
    } else {
      setShowMinimap(false);
    }
  }, [zoom]);

  useEffect(() => {
    if (ContainerRef.current) {
      resizeObserver.observe(ContainerRef.current);
    }
    return () => {
      if (ContainerRef.current) {
        resizeObserver.unobserve(ContainerRef.current);
      }
    };
  }, [ContainerRef]);

  // Handle double click to zoom in or out
  // Generated by Copilot
  const handleDoubleClick = (e: React.MouseEvent) => {
    // Get cursor position relative to canvas container
    const rect = canvasContainerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // If already zoomed in, reset zoom
    if (zoom > 1.2) {
      setZoom(1);
      // Center the image
      if (canvasContainerRef.current && ContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        const imgRect = ContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgRect.width / zoom) / 2,
          y: (containerRect.height - imgRect.height / zoom) / 2,
        });
      }
    } else {
      // Zoom in to 2x at the cursor position
      const newZoom = 2;
      // Adjust position to zoom toward the cursor position
      const newPosition = {
        x: mouseX - (mouseX - position.x) * (newZoom / zoom),
        y: mouseY - (mouseY - position.y) * (newZoom / zoom),
      };

      setZoom(newZoom);
      setPosition(newPosition);
    }
  };

  // Handle clicks on the minimap for navigation
  // Generated by Copilot
  const handleMinimapClick = (e: React.MouseEvent) => {
    const minimap = minimapRef.current;
    const container = canvasContainerRef.current;
    if (!minimap || !container) return;

    const minimapRect = minimap.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Get click position as a percentage of the minimap
    const clickXPercent = (e.clientX - minimapRect.left) / minimapRect.width;
    const clickYPercent = (e.clientY - minimapRect.top) / minimapRect.height;

    // Calculate the new position
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;

    // Calculate where to center the view based on the click position
    const newPositionX =
      -(clickXPercent * containerWidth * zoom) + containerWidth / 2;
    const newPositionY =
      -(clickYPercent * containerHeight * zoom) + containerHeight / 2;

    setPosition({ x: newPositionX, y: newPositionY });
  };

  if (state.isLoading || !state.imgDim) {
    return <Loader message="Loading canvas data..." />;
  }

  if (state.tabs.length === 0 || state.selectedTab === -1) {
    return null;
  }

  return (
    <>
      <TabNavigation
        tabs={state.tabs}
        selectedTab={state.selectedTab}
        setSelectedTab={actions.setSelectedTab}
        setTabs={actions.setTabs}
        overlayRef={refs.overlayRef}
        isMarkingAllDone={state.canvasSaveStatus.isMarkingAllDone}
      />
      {toolbar}{" "}
      <div
        className={`canvas-container ${
          React.isValidElement(children) &&
          (children as React.ReactElement<{ layerState?: string }>).props
            ?.layerState === "hand"
            ? "hand-mode"
            : ""
        }`}
        ref={canvasContainerRef}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onDoubleClick={handleDoubleClick}
      >
        {/* Zoom controls */}
        <div className="zoom-controls">
          {" "}
          <button
            className="zoom-button"
            onClick={() => setZoom(Math.max(zoom - 0.2, 0.5))}
            title="Zoom out"
            disabled={zoom <= 0.5}
          >
            -
          </button>
          <div className="zoom-indicator">{Math.round(zoom * 100)}%</div>
          <button
            className="zoom-button"
            onClick={() => setZoom(Math.min(zoom + 0.2, 5))}
            title="Zoom in"
            disabled={zoom >= 5}
          >
            +
          </button>
          {zoom !== 1 && (
            <button
              className="zoom-button reset"
              onClick={() => {
                setZoom(1);
                // Center the image
                if (
                  canvasContainerRef.current &&
                  ContainerRef.current &&
                  imgRef.current
                ) {
                  const containerRect =
                    canvasContainerRef.current.getBoundingClientRect();
                  const imgNaturalAspectRatio =
                    imgRef.current.naturalWidth / imgRef.current.naturalHeight;
                  const containerAspectRatio =
                    containerRect.width / containerRect.height;

                  let imgWidth = containerRect.width;
                  let imgHeight = containerRect.height;

                  // Adjust dimensions to maintain aspect ratio
                  if (imgNaturalAspectRatio > containerAspectRatio) {
                    // Image is wider than container
                    imgHeight = containerRect.width / imgNaturalAspectRatio;
                  } else {
                    // Image is taller than container
                    imgWidth = containerRect.height * imgNaturalAspectRatio;
                  }

                  // Calculate the center position
                  setPosition({
                    x: (containerRect.width - imgWidth) / 2,
                    y: (containerRect.height - imgHeight) / 2,
                  });
                }
              }}
              title="Reset zoom"
            >
              ↺
            </button>
          )}
        </div>
        {/* Minimap component - Generated by Copilot */}
        {showMinimap && (
          <div
            className="minimap"
            ref={minimapRef}
            onClick={handleMinimapClick}
          >
            <div className="minimap-image">
              <img src={image.src} alt="Navigation map" />{" "}
              <div
                className="minimap-viewport"
                style={{
                  width: `${100 / zoom}%`,
                  height: `${100 / zoom}%`,
                  transform: `translate(
                    ${
                      -position.x * (100 / (imgRef.current?.clientWidth || 1))
                    }%,
                    ${
                      -position.y * (100 / (imgRef.current?.clientHeight || 1))
                    }%
                  )`,
                }}
              ></div>
            </div>
          </div>
        )}{" "}
        <div
          className="image-container"
          ref={ContainerRef}
          style={{
            transform: `scale(${zoom})`,
            transformOrigin: "0 0",
            position: "absolute",
            left: `${position.x}px`,
            top: `${position.y}px`,
            cursor: isDragging ? "grabbing" : "grab",
          }}
        >
          <img src={image.src} alt={image.filename} ref={imgRef} />
          {children}
        </div>
      </div>
    </>
  );
}
