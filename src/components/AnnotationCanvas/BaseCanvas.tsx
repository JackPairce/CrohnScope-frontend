// Generated by Copilot
import { ApiImage, getStainNormalizationImage } from "@/lib/api";
import React, {
  Dispatch,
  ReactNode,
  RefObject,
  SetStateAction,
  useEffect,
  useRef,
  useState,
} from "react";
import Loader from "../loader";
import { NdarrayToImgSrc } from "./MaskUtils";
import TabNavigation from "./TabNavigation";
import { GlobalModes, SaveSatues, Tab } from "./types";

type StainViewType = "original" | "inorm" | "hematoxylin" | "eosin";

interface BaseCanvasProps {
  image: ApiImage;
  state: {
    mode: GlobalModes;
    tabs: Tab[];
    selectedTab: number;
    canvasSaveStatus: SaveSatues;
    imgDim: { width: number; height: number } | null;
    isLoading: boolean;
  };
  refs: {
    overlayRef: RefObject<HTMLCanvasElement>;
  };
  actions: {
    setTabs: Dispatch<SetStateAction<Tab[]>>;
    setSelectedTab: (index: number) => void;
    setIsLoading: Dispatch<SetStateAction<boolean>>;
  };
  toolbar: ReactNode;
  children: ReactNode;
}

export default function BaseCanvas({
  image,
  state,
  refs,
  actions,
  toolbar,
  children,
}: BaseCanvasProps) {
  const ContainerRef = useRef<HTMLDivElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const minimapRef = useRef<HTMLDivElement>(null);

  // Add state for zoom level and panning
  const [zoom, setZoom] = useState<number>(1);
  const [position, setPosition] = useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  });
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [dragStart, setDragStart] = useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  });
  const [showMinimap, setShowMinimap] = useState<boolean>(false);
  const [triggerResize, setTriggerResize] = useState<boolean>(false);

  // Stain normalization view states
  const [currentStainView, setCurrentStainView] =
    useState<StainViewType>("original");
  const [stainViews, setStainViews] = useState<Record<StainViewType, string>>({
    original: image.src,
    inorm: "",
    hematoxylin: "",
    eosin: "",
  });
  const [loadingStainView, setLoadingStainView] = useState<boolean>(false);

  const resizeObserver = new ResizeObserver(() => {
    setTriggerResize((prev) => !prev);
  });

  // Load stain normalization views
  const loadStainViews = async () => {
    // Generated by Copilot
    if (!image.id) return;

    try {
      setLoadingStainView(true);
      const views = await getStainNormalizationImage(image.id);
      setStainViews({
        original: image.src, // Always use the provided image src for original
        inorm: NdarrayToImgSrc(views.inorm),
        hematoxylin: NdarrayToImgSrc(views.hematoxylin),
        eosin: NdarrayToImgSrc(views.eosin),
      });
    } catch (error) {
      console.error("Failed to load stain normalization views:", error);
      // Fallback to original image for all views
      setStainViews({
        original: image.src,
        inorm: image.src,
        hematoxylin: image.src,
        eosin: image.src,
      });
    } finally {
      setLoadingStainView(false);
    }
  };

  // Generated by Copilot
  useEffect(() => {
    if (ContainerRef.current && imgRef.current) {
      const OriginalimgWidth = imgRef.current.naturalWidth;
      const OriginalimgHeight = imgRef.current.naturalHeight;
      const imgWidth = imgRef.current.clientWidth;
      const imgHeight = imgRef.current.clientHeight;

      const imgRatio = imgWidth / imgHeight;
      const OriginalimgRatio = OriginalimgWidth / OriginalimgHeight;
      if (imgRatio > OriginalimgRatio) {
        ContainerRef.current.style.width = `${imgHeight * OriginalimgRatio}px`;
      } else {
        ContainerRef.current.style.height = `${imgWidth / OriginalimgRatio}px`;
      }

      // Reset zoom and position when image changes
      setZoom(1);

      // Center the image in the container
      if (canvasContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgWidth) / 2,
          y: (containerRect.height - imgHeight) / 2,
        });
      }
    }
  }, [image, triggerResize]);
  // Handle mouse wheel zoom
  const handleZoom = (e: WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY;

    // Calculate new zoom level with limits
    const newZoom = Math.min(Math.max(zoom + (delta > 0 ? -0.1 : 0.1), 0.5), 5);

    // Get cursor position relative to canvas container
    const rect = canvasContainerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Adjust position to zoom toward the cursor position
    const newPosition = {
      x: mouseX - (mouseX - position.x) * (newZoom / zoom),
      y: mouseY - (mouseY - position.y) * (newZoom / zoom),
    };

    setZoom(newZoom);
    setPosition(newPosition);
  };

  // Handle mouse drag start
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0) {
      // Left button only
      setIsDragging(true);
      setDragStart({
        x: e.clientX - position.x,
        y: e.clientY - position.y,
      });
    }
  };

  // Handle mouse dragging
  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      setPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y,
      });
    }
  };

  // Handle mouse drag end
  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // Handle keyboard shortcuts for zoom
  const handleKeyDown = (e: KeyboardEvent) => {
    // Ctrl/Cmd + plus key to zoom in
    if ((e.ctrlKey || e.metaKey) && e.key === "+") {
      e.preventDefault();
      setZoom(Math.min(zoom + 0.2, 5));
    }

    // Ctrl/Cmd + minus key to zoom out
    if ((e.ctrlKey || e.metaKey) && e.key === "-") {
      e.preventDefault();
      setZoom(Math.max(zoom - 0.2, 0.5));
    }

    // Ctrl/Cmd + 0 to reset zoom
    if ((e.ctrlKey || e.metaKey) && e.key === "0") {
      e.preventDefault();
      setZoom(1);
      // Center the image
      if (canvasContainerRef.current && ContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        const imgRect = ContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgRect.width / zoom) / 2,
          y: (containerRect.height - imgRect.height / zoom) / 2,
        });
      }
    }
  };
  // Add wheel event and keyboard listeners
  useEffect(() => {
    const container = canvasContainerRef.current;
    if (container) {
      container.addEventListener("wheel", handleZoom, { passive: false });

      // Add keyboard event listener to the window
      window.addEventListener("keydown", handleKeyDown);
    }

    return () => {
      if (container) {
        container.removeEventListener("wheel", handleZoom);
      }
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [zoom, position]);

  // Show minimap when zoomed in beyond a threshold
  useEffect(() => {
    if (zoom > 1.5) {
      setShowMinimap(true);
    } else {
      setShowMinimap(false);
    }
  }, [zoom]);

  useEffect(() => {
    if (ContainerRef.current) {
      resizeObserver.observe(ContainerRef.current);
    }
    return () => {
      if (ContainerRef.current) {
        resizeObserver.unobserve(ContainerRef.current);
      }
    };
  }, [ContainerRef]);

  // Handle double click to zoom in or out
  const handleDoubleClick = (e: React.MouseEvent) => {
    // Get cursor position relative to canvas container
    const rect = canvasContainerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // If already zoomed in, reset zoom
    if (zoom > 1.2) {
      setZoom(1);
      // Center the image
      if (canvasContainerRef.current && ContainerRef.current) {
        const containerRect =
          canvasContainerRef.current.getBoundingClientRect();
        const imgRect = ContainerRef.current.getBoundingClientRect();
        setPosition({
          x: (containerRect.width - imgRect.width / zoom) / 2,
          y: (containerRect.height - imgRect.height / zoom) / 2,
        });
      }
    } else {
      // Zoom in to 2x at the cursor position
      const newZoom = 2;
      // Adjust position to zoom toward the cursor position
      const newPosition = {
        x: mouseX - (mouseX - position.x) * (newZoom / zoom),
        y: mouseY - (mouseY - position.y) * (newZoom / zoom),
      };

      setZoom(newZoom);
      setPosition(newPosition);
    }
  };

  // Handle clicks on the minimap for navigation
  const handleMinimapClick = (e: React.MouseEvent) => {
    const minimap = minimapRef.current;
    const container = canvasContainerRef.current;
    if (!minimap || !container) return;

    const minimapRect = minimap.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Get click position as a percentage of the minimap
    const clickXPercent = (e.clientX - minimapRect.left) / minimapRect.width;
    const clickYPercent = (e.clientY - minimapRect.top) / minimapRect.height;

    // Calculate the new position
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;

    // Calculate where to center the view based on the click position
    const newPositionX =
      -(clickXPercent * containerWidth * zoom) + containerWidth / 2;
    const newPositionY =
      -(clickYPercent * containerHeight * zoom) + containerHeight / 2;

    setPosition({ x: newPositionX, y: newPositionY });
  };

  // Load stain views when image changes
  useEffect(() => {
    // Reset to original view when image changes
    setCurrentStainView("original");

    // If image has an ID, load stain views
    if (image.id) {
      loadStainViews();
    }
  }, [image.id]);

  if (state.isLoading || !state.imgDim) {
    return <Loader message="Loading canvas data..." />;
  }

  if (state.tabs.length === 0 || state.selectedTab === -1) {
    return null;
  }

  return (
    <>
      <TabNavigation
        tabs={state.tabs}
        selectedTab={state.selectedTab}
        setSelectedTab={actions.setSelectedTab}
        setTabs={actions.setTabs}
        overlayRef={refs.overlayRef}
        isMarkingAllDone={state.canvasSaveStatus.isMarkingAllDone}
      />
      {toolbar}{" "}
      <div
        className={`canvas-container ${
          React.isValidElement(children) &&
          (children as React.ReactElement<{ layerState?: string }>).props
            ?.layerState === "hand"
            ? "hand-mode"
            : ""
        }`}
        ref={canvasContainerRef}
        onMouseDown={state.mode == "hand" ? handleMouseDown : undefined}
        onMouseMove={state.mode == "hand" ? handleMouseMove : undefined}
        onMouseUp={state.mode == "hand" ? handleMouseUp : undefined}
        onMouseLeave={state.mode == "hand" ? handleMouseUp : undefined}
        onDoubleClick={state.mode == "hand" ? handleDoubleClick : undefined}
      >
        {" "}
        {/* Controls bar with zoom and stain view controls */}
        <div className="canvas-controls-bar">
          {/* Zoom controls */}
          <div className="zoom-controls">
            <button
              className="zoom-button"
              onClick={() => setZoom(Math.max(zoom - 0.2, 0.5))}
              title="Zoom out"
              disabled={zoom <= 0.5}
            >
              -
            </button>
            <div className="zoom-indicator">{Math.round(zoom * 100)}%</div>
            <button
              className="zoom-button"
              onClick={() => setZoom(Math.min(zoom + 0.2, 5))}
              title="Zoom in"
              disabled={zoom >= 5}
            >
              +
            </button>
            {zoom !== 1 && (
              <button
                className="zoom-button reset"
                onClick={() => {
                  setZoom(1);
                  // Center the image
                  if (
                    canvasContainerRef.current &&
                    ContainerRef.current &&
                    imgRef.current
                  ) {
                    const containerRect =
                      canvasContainerRef.current.getBoundingClientRect();
                    const imgNaturalAspectRatio =
                      imgRef.current.naturalWidth /
                      imgRef.current.naturalHeight;
                    const containerAspectRatio =
                      containerRect.width / containerRect.height;

                    let imgWidth = containerRect.width;
                    let imgHeight = containerRect.height;

                    // Adjust dimensions to maintain aspect ratio
                    if (imgNaturalAspectRatio > containerAspectRatio) {
                      // Image is wider than container
                      imgHeight = containerRect.width / imgNaturalAspectRatio;
                    } else {
                      // Image is taller than container
                      imgWidth = containerRect.height * imgNaturalAspectRatio;
                    }

                    // Calculate the center position
                    setPosition({
                      x: (containerRect.width - imgWidth) / 2,
                      y: (containerRect.height - imgHeight) / 2,
                    });
                  }
                }}
                title="Reset zoom"
              >
                ↺
              </button>
            )}
          </div>

          {/* Stain view controls */}
          <div className="stain-view-controls">
            <div className="stain-view-label">View:</div>
            <div className="stain-buttons">
              <button
                className={`stain-button ${
                  currentStainView === "original" ? "active" : ""
                }`}
                onClick={() => setCurrentStainView("original")}
                disabled={loadingStainView}
                title="Original image"
              >
                Original
              </button>
              <button
                className={`stain-button ${
                  currentStainView === "inorm" ? "active" : ""
                }`}
                onClick={() => setCurrentStainView("inorm")}
                disabled={loadingStainView || !stainViews.inorm}
                title="Intensity normalized"
              >
                I-Norm
              </button>
              <button
                className={`stain-button ${
                  currentStainView === "hematoxylin" ? "active" : ""
                }`}
                onClick={() => setCurrentStainView("hematoxylin")}
                disabled={loadingStainView || !stainViews.hematoxylin}
                title="Hematoxylin component"
              >
                H
              </button>
              <button
                className={`stain-button ${
                  currentStainView === "eosin" ? "active" : ""
                }`}
                onClick={() => setCurrentStainView("eosin")}
                disabled={loadingStainView || !stainViews.eosin}
                title="Eosin component"
              >
                E
              </button>
              {loadingStainView && (
                <span className="loading-indicator">Loading...</span>
              )}
            </div>
          </div>
        </div>
        {/* Minimap component - Generated by Copilot */}
        {showMinimap && (
          <div
            className="minimap"
            ref={minimapRef}
            onClick={handleMinimapClick}
          >
            {" "}
            <div className="minimap-image">
              <img
                src={stainViews[currentStainView] || image.src}
                alt={`Navigation map - ${currentStainView} view`}
              />
              <div
                className="minimap-viewport"
                style={{
                  width: `${100 / zoom}%`,
                  height: `${100 / zoom}%`,
                  transform: `translate(
                    ${
                      -position.x * (100 / (imgRef.current?.clientWidth || 1))
                    }%,
                    ${
                      -position.y * (100 / (imgRef.current?.clientHeight || 1))
                    }%
                  )`,
                }}
              ></div>
            </div>
          </div>
        )}{" "}
        <div
          className="image-container"
          ref={ContainerRef}
          style={{
            transform: `scale(${zoom})`,
            transformOrigin: "0 0",
            position: "absolute",
            left: `${position.x}px`,
            top: `${position.y}px`,
            cursor: isDragging ? "grabbing" : "grab",
          }}
        >
          <img
            src={stainViews[currentStainView] || image.src}
            alt={`${image.filename} - ${currentStainView} view`}
            ref={imgRef}
            onError={(e) => {
              console.error(
                `Failed to load ${currentStainView} view, falling back to original`,
                e.currentTarget.src
              );
              // If stain view fails to load, fall back to original
              if (currentStainView !== "original") {
                setCurrentStainView("original");
              }
            }}
          />
          {children}
        </div>
      </div>
    </>
  );
}
