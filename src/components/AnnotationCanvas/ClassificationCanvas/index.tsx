"use client";
// Generated by Copilot
import { useAnnotationContext } from "@/contexts/AnnotationContext";
import {
  ApiImage,
  MaskMatricesResponse,
  getMaskMatrices,
  updateRegionHealth,
} from "@/lib/api";
import { useEffect, useState } from "react";
import BaseCanvas from "../BaseCanvas";
import { useAnnotationCanvas } from "../hooks/useAnnotationCanvas";
import { CanvasActionsHandler } from "../hooks/useCanvasActions";
import ToolBar from "../ToolBar";
import type { State } from "./LayerState";
import ClassificationToolbar from "./ToolBar";

// Helper function to find the first pixel with a given label
function findFirstPixelWithLabel(
  labeledRegions: number[][],
  label: number
): { x: number; y: number } | null {
  for (let y = 0; y < labeledRegions.length; y++) {
    for (let x = 0; x < labeledRegions[y].length; x++) {
      if (labeledRegions[y][x] === label) {
        return { x, y };
      }
    }
  }
  return null;
}

export default function ClassificationWorkspace({
  image,
}: {
  image: ApiImage;
}) {
  const { state, refs, actions } = useAnnotationCanvas(image);
  const { setSaveStatus, saveCurrent, setCurrentImage } =
    useAnnotationContext();
  const [layerState, setLayerState] = useState<State>("all");

  // Initialize action extensions
  const extendedActions = {
    ...actions,
    setCurrentImage,
  };

  // Initialize CanvasActionsHandler
  const canvasActions = new CanvasActionsHandler(
    state,
    extendedActions,
    setSaveStatus,
    image,
    {
      saveCurrent: async () => {
        if (!matrixData || !state.tabs?.[state.selectedTab]?.mask_id) return;

        // Set saving state
        setSaveStatus((prev) => ({ ...prev, isSaving: true }));

        try {
          // Update all modified regions in current mask
          const promises = matrixData.masks?.map(async (mask) => {
            if (mask.mask_id === state.tabs[state.selectedTab].mask_id) {
              // For each different label in the mask
              const labels = new Set<number>();
              mask.labeledRegions.forEach((row) =>
                row.forEach((label) => {
                  if (label !== 0) labels.add(label);
                })
              );

              // For each label, find first pixel and use its health status
              const updatePromises = Array.from(labels).map(async (label) => {
                const firstPixel = findFirstPixelWithLabel(
                  mask.labeledRegions,
                  label
                );
                if (firstPixel) {
                  const healthValue = mask.mask[firstPixel.y][firstPixel.x];
                  // Convert numeric health value to boolean
                  const isHealthy = healthValue === 1;
                  await updateRegionHealth(mask.mask_id, label, isHealthy);
                }
              });

              await Promise.all(updatePromises);
            }
          });

          if (promises) {
            await Promise.all(promises);
          }

          // Reset save status after successful save
          setSaveStatus({
            isSaving: false,
            isModified: false,
            isMarkingAllDone: false,
          });
        } catch (error) {
          console.error("Failed to save masks:", error);
          setSaveStatus((prev) => ({
            ...prev,
            isSaving: false,
          }));
        }
      },
    }
  );

  // State for matrix data
  const [matrixData, setMatrixData] = useState<MaskMatricesResponse | null>(
    null
  );
  const isAllDone = state.tabs.every((tab) => tab.isDone);

  // Load matrix data on mount or when image changes
  useEffect(() => {
    const loadMatrixData = async () => {
      if (image.id) {
        const data = await getMaskMatrices(image.id);
        setMatrixData(data);
      }
    };
    loadMatrixData();
  }, [image.id]);

  // Return null for loading or invalid states
  if (
    state.isLoading ||
    !state.imgDim ||
    state.selectedTab === -1 ||
    !state.tabs?.[state.selectedTab]
  ) {
    return null;
  }

  return (
    <BaseCanvas
      image={image}
      state={state}
      refs={refs}
      actions={actions}
      toolbar={
        <ToolBar
          saveStatus={state.canvasSaveStatus}
          saveMasks={() => canvasActions.saveMasks()}
          isAllDone={isAllDone}
          MarkAllDone={async () => {
            await canvasActions.markAllDone();
            if (isAllDone) {
              await setCurrentImage(null);
            }
          }}
          markCurrentMask={async () => {
            await canvasActions.markCurrentMask();
            if (state.tabs.every((tab) => tab.isDone)) {
              await setCurrentImage(null);
            }
          }}
          saveAll={() => canvasActions.saveMasks()}
          saveAndMark={async () => {
            await canvasActions.saveAndMark();
            if (isAllDone) {
              await setCurrentImage(null);
            }
          }}
          state={state}
        >
          <ClassificationToolbar
            layerState={layerState}
            setLayerState={setLayerState}
          />
        </ToolBar>
      }
    >
      {matrixData && (
        <div className="flex-1 h-full relative">
          {/* Canvas content here */}
        </div>
      )}
    </BaseCanvas>
  );
}
