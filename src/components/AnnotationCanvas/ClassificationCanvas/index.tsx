"use client";
// Generated by Copilot
import { useAnnotationContext } from "@/contexts/AnnotationContext";
import {
  ApiImage,
  MaskMatricesResponse,
  getMaskMatrices,
  updateRegionHealth,
} from "@/lib/api";
import { useCallback, useEffect, useRef, useState } from "react";
import BaseCanvas from "../BaseCanvas";
import { useAnnotationCanvas } from "../hooks/useAnnotationCanvas";
import ToolBar from "../ToolBar";
import type { State } from "./LayerState";
import ClassificationToolbar from "./ToolBar";

// Helper function to find the first pixel with a given label
function findFirstPixelWithLabel(
  labeledRegions: number[][],
  label: number
): { x: number; y: number } | null {
  for (let y = 0; y < labeledRegions.length; y++) {
    for (let x = 0; x < labeledRegions[y].length; x++) {
      if (labeledRegions[y][x] === label) {
        return { x, y };
      }
    }
  }
  return null;
}

export default function ClassificationWorkspace({
  image,
}: {
  image: ApiImage;
}) {
  const { state, refs, actions } = useAnnotationCanvas(image);
  const { setSaveStatus, saveCurrent } = useAnnotationContext();

  // Layer canvases for classification
  const healthyRef = useRef<HTMLCanvasElement>(null);
  const unhealthyRef = useRef<HTMLCanvasElement>(null);
  const [layerState, setLayerState] = useState<State>("all");

  // Matrix data state for classification
  const [matrixData, setMatrixData] = useState<MaskMatricesResponse | null>(
    null
  );

  // Clear all canvases
  const clearCanvases = useCallback(() => {
    if (healthyRef.current && unhealthyRef.current && refs.overlayRef.current) {
      const healthyCtx = healthyRef.current.getContext("2d");
      const unhealthyCtx = unhealthyRef.current.getContext("2d");
      const overlayCtx = refs.overlayRef.current.getContext("2d");

      healthyCtx?.clearRect(
        0,
        0,
        healthyRef.current.width,
        healthyRef.current.height
      );
      unhealthyCtx?.clearRect(
        0,
        0,
        unhealthyRef.current.width,
        unhealthyRef.current.height
      );
      overlayCtx?.clearRect(
        0,
        0,
        refs.overlayRef.current.width,
        refs.overlayRef.current.height
      );
    }
  }, [refs.overlayRef]);

  // Reset all state when image changes or becomes null
  useEffect(() => {
    clearCanvases();
    setMatrixData(null);
    actions.setCanvasSaveStatus({
      isSaving: false,
      isModified: false,
      isMarkingAllDone: false,
    });

    // If no image, just return after clearing state
    if (!image?.id) {
      return;
    }

    // Get new mask matrices only if we have an image and selected tab
    if (state.selectedTab !== -1 && state.tabs?.[state.selectedTab]?.mask_id) {
      getMaskMatrices(image.id)
        .then((data) => {
          setMatrixData(data);
        })
        .catch(console.error);
    }
  }, [image, clearCanvases, state.selectedTab, state.tabs]); // Added state.selectedTab and state.tabs as dependencies

  // Handle matrix data updates and canvas drawing
  useEffect(() => {
    // Don't proceed if missing required data
    if (
      !state.imgDim ||
      state.selectedTab === -1 ||
      !matrixData ||
      !state.tabs?.[state.selectedTab]?.mask_id
    ) {
      return;
    }

    // Find the active mask that matches the current tab
    const activeMask = matrixData.masks?.find(
      (mask) => mask.mask_id === state.tabs[state.selectedTab].mask_id
    );

    if (!activeMask) return;

    // Clear canvases before drawing new content
    clearCanvases();

    // Set canvas dimensions
    if (healthyRef.current && unhealthyRef.current && refs.overlayRef.current) {
      // Set all canvases to exact image dimensions
      [
        healthyRef.current,
        unhealthyRef.current,
        refs.overlayRef.current,
      ].forEach((canvas) => {
        canvas.width = state.imgDim?.width || 0;
        canvas.height = state.imgDim?.height || 0;
      });

      const healthyCtx = healthyRef.current.getContext("2d");
      const unhealthyCtx = unhealthyRef.current.getContext("2d");

      if (healthyCtx && unhealthyCtx) {
        // Create image data for healthy and unhealthy regions
        const healthyImageData = healthyCtx.createImageData(
          state.imgDim.width,
          state.imgDim.height
        );
        const unhealthyImageData = unhealthyCtx.createImageData(
          state.imgDim.width,
          state.imgDim.height
        );

        // Initialize all pixels with 0 alpha
        for (let i = 3; i < healthyImageData.data.length; i += 4) {
          healthyImageData.data[i] = 0;
          unhealthyImageData.data[i] = 0;
        }

        // Process each pixel
        for (let y = 0; y < activeMask.mask.length; y++) {
          for (let x = 0; x < activeMask.mask[y].length; x++) {
            const maskValue = activeMask.mask[y][x];

            if (maskValue !== 0) {
              // Skip background (0)
              const idx = (y * state.imgDim.width + x) * 4;

              // Value 2 means healthy (green), 1 means unhealthy (red)
              if (maskValue === 2) {
                // Draw healthy region in green
                healthyImageData.data[idx + 0] = 0; // R
                healthyImageData.data[idx + 1] = 255; // G
                healthyImageData.data[idx + 2] = 0; // B
                healthyImageData.data[idx + 3] = 255; // Fully opaque
              } else if (maskValue === 1) {
                // Draw unhealthy region in red
                unhealthyImageData.data[idx + 0] = 255; // R
                unhealthyImageData.data[idx + 1] = 0; // G
                unhealthyImageData.data[idx + 2] = 0; // B
                unhealthyImageData.data[idx + 3] = 255; // Fully opaque
              }
            }
          }
        }

        healthyCtx.putImageData(healthyImageData, 0, 0);
        unhealthyCtx.putImageData(unhealthyImageData, 0, 0);
      }
    }
  }, [state.imgDim, state.selectedTab, state.tabs, matrixData, clearCanvases]);
  // Handle region clicks
  const handleRegionClick = useCallback(
    async (e: React.MouseEvent<HTMLCanvasElement>) => {
      // Skip region selection if in hand mode
      if (layerState === "hand") return;

      if (
        !state.imgDim ||
        state.selectedTab === -1 ||
        !matrixData ||
        !state.tabs?.[state.selectedTab]?.mask_id
      )
        return;

      // Find the active mask
      const activeMask = matrixData.masks?.find(
        (mask) => mask.mask_id === state.tabs[state.selectedTab].mask_id
      );

      if (!activeMask) return;

      // Get click coordinates in canvas space
      const canvas = e.currentTarget;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(
        (e.clientX - rect.left) * (canvas.width / rect.width)
      );
      const y = Math.floor(
        (e.clientY - rect.top) * (canvas.height / rect.height)
      );

      // Get the region label from connected components matrix
      const clickedLabel = activeMask.labeledRegions[y]?.[x];
      if (!clickedLabel || clickedLabel === 0) return; // Ignore background

      // Get current health status of the clicked region
      const currentHealth = activeMask.mask[y][x];
      // Toggle health status: 1 (unhealthy) -> 2 (healthy) or 2 -> 1
      const newHealth = currentHealth === 1 ? 2 : 1;

      try {
        // Update health status for all pixels with same region label in local state
        activeMask.labeledRegions.forEach((row, rowIndex) => {
          row.forEach((label, colIndex) => {
            if (label === clickedLabel) {
              activeMask.mask[rowIndex][colIndex] = newHealth;
            }
          });
        });

        // Just update local state, backend update will happen on save all
        setMatrixData({
          ...matrixData,
          masks: matrixData.masks?.map((mask) =>
            mask.mask_id === activeMask.mask_id ? activeMask : mask
          ),
        });

        // Mark as modified
        setSaveStatus((prev) => ({
          ...prev,
          isModified: true,
        }));
      } catch (error) {
        console.error("Failed to update region:", error);
      }
    },
    [
      state.imgDim,
      state.selectedTab,
      state.tabs,
      matrixData,
      image?.id,
      setSaveStatus,
      layerState,
    ]
  );

  if (
    state.isLoading ||
    !state.imgDim ||
    state.selectedTab === -1 ||
    !state.tabs?.[state.selectedTab]
  ) {
    return null;
  }

  const updateMaskRegions = async () => {
    if (!matrixData || !state.tabs?.[state.selectedTab]?.mask_id) return;

    try {
      // First try to use the saveCurrent function from context
      if (saveCurrent) {
        await saveCurrent();
        return;
      }

      // Fallback implementation if saveCurrent is not available
      // Set saving state
      setSaveStatus((prev) => ({ ...prev, isSaving: true }));

      // Update all modified regions in current mask
      const promises = matrixData.masks?.map(async (mask) => {
        if (mask.mask_id === state.tabs[state.selectedTab].mask_id) {
          // For each different label in the mask
          const labels = new Set<number>();
          mask.labeledRegions.forEach((row) =>
            row.forEach((label) => {
              if (label !== 0) labels.add(label);
            })
          );

          // Update each labeled region
          for (const label of labels) {
            const firstPixel = findFirstPixelWithLabel(
              mask.labeledRegions,
              label
            );
            if (firstPixel) {
              const isHealthy = mask.mask[firstPixel.y][firstPixel.x] === 2;
              await updateRegionHealth(mask.mask_id, label, isHealthy);
            }
          }
        }
      });

      if (promises) await Promise.all(promises);

      // Reload matrix data to ensure sync with backend
      const newMatrixData = await getMaskMatrices(image.id);
      setMatrixData(newMatrixData);

      // Update save status after successful save
      setSaveStatus({
        isSaving: false,
        isModified: false,
        isMarkingAllDone: false,
      });
    } catch (error) {
      console.error("Failed to save all regions:", error);
      // Reset saving state on error
      setSaveStatus((prev) => ({
        ...prev,
        isSaving: false,
      }));
    }
  };

  const markAllTabsAsDone = async () => {
    try {
      // Update status
      setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: true,
      }));

      // Mark all tabs as done
      actions.setTabs((prev) => prev.map((tab) => ({ ...tab, isDone: true })));

      // TODO: Implement API call to mark all as done
      console.log("Mark all tabs as done for image:", image?.id);

      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 300));

      // Set modified flag and then save using the context's saveCurrent function
      setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: false,
        isModified: true, // This will prompt for save
      }));

      // Save the changes immediately
      await saveCurrent();
    } catch (error) {
      console.error("Failed to mark all tabs as done:", error);
      setSaveStatus((prev) => ({
        ...prev,
        isMarkingAllDone: false,
      }));
    }
  };

  return (
    <BaseCanvas
      image={image}
      state={state}
      refs={refs}
      actions={actions}
      toolbar={
        <ToolBar
          saveStatus={state.canvasSaveStatus}
          saveMasks={updateMaskRegions}
          isAllDone={state.tabs.every((tab) => tab.isDone)}
          MarkAllDone={markAllTabsAsDone}
        >
          <ClassificationToolbar
            layerState={layerState}
            setLayerState={setLayerState}
          />
        </ToolBar>
      }
    >
      <div className={""}>
        <canvas
          ref={healthyRef}
          className="healthy"
          width={state.imgDim.width}
          height={state.imgDim.height}
          style={{
            zIndex: 2,
            pointerEvents: "none",
            display: ["all", "healthy"].includes(layerState as string)
              ? "block"
              : "none",
          }}
        />
        <canvas
          ref={unhealthyRef}
          className="unhealthy"
          width={state.imgDim.width}
          height={state.imgDim.height}
          style={{
            zIndex: 2,
            pointerEvents: "none",
            display: ["all", "unhealthy"].includes(layerState as string)
              ? "block"
              : "none",
          }}
        />{" "}
        <canvas
          ref={refs.overlayRef}
          className={`cursor ${layerState === "hand" ? "hand-cursor" : ""}`}
          width={state.imgDim.width}
          height={state.imgDim.height}
          style={{
            zIndex: layerState === "hand" ? 1 : 3,
            cursor: layerState === "hand" ? "grab" : "pointer",
            pointerEvents: layerState === "hand" ? "none" : "auto",
          }}
          onClick={handleRegionClick}
          onMouseDown={(e) => layerState === "hand" && e.preventDefault()}
          onDragStart={(e) => e.preventDefault()}
        />
      </div>
    </BaseCanvas>
  );
}
